import 'dart:convert';
import 'dart:io';
import 'package:http/http.dart' as http;
import 'package:intl/date_symbol_data_local.dart'; // A√±ade esta importaci√≥n
import '../models/invoice_model.dart';

class InvoiceService {
  static const List<String> possibleUrls = [
    'https://invoice.oral-plus.com/api',  
    'https://invoice.oral-plus.com/api',      
    'https://invoice.oral-plus.com/api',   
    'https://invoice.oral-plus.com/api',   
    'https://invoice.oral-plus.com/api',  
    'https://invoice.oral-plus.com/api', 
  ];
  
  static String? _workingUrl;
  static const Duration timeout = Duration(seconds: 15);

  /// Inicializa el formato de fechas
  static Future<void> initialize() async {
    await initializeDateFormatting(); // Inicializa los formatos de fecha
  }

  /// Encuentra la URL que funciona
  static Future<String?> findWorkingUrl() async {
    if (_workingUrl != null) {
      print('üîÑ Usando URL en cache: $_workingUrl');
      return _workingUrl;
    }

    print('üîç Buscando servidor ORAL-PLUS...');
    print('üì° Probando ${possibleUrls.length} URLs posibles...');
    
    for (int i = 0; i < possibleUrls.length; i++) {
      final url = possibleUrls[i];
      try {
        print('üîÑ [${i + 1}/${possibleUrls.length}] Probando: $url');
        
        final response = await http.get(
          Uri.parse('$url/test'),
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
          },
        ).timeout(const Duration(seconds: 5));

        if (response.statusCode == 200) {
          final data = json.decode(response.body);
          if (data['success'] == true) {
            _workingUrl = url;
            print('‚úÖ Servidor encontrado en: $url');
            print('üìä Estado: ${data['status']}');
            print('üåê Host: ${data['server']?['host'] ?? 'N/A'}');
            print('üîß Node.js: ${data['server']?['nodeVersion'] ?? 'N/A'}');
          
            // Mostrar IPs disponibles si las hay
            if (data['network'] != null && data['network']['interfaces'] != null) {
              final interfaces = data['network']['interfaces'] as List;
              if (interfaces.isNotEmpty) {
                print('üìç IPs disponibles del servidor:');
                for (var iface in interfaces) {
                  print('   ${iface['interface']}: ${iface['url']}');
                }
              }
            }
          
            return url;
          }
        }
      } catch (e) {
        final errorMsg = e.toString();
        if (errorMsg.length > 100) {
          print('‚ùå Error en $url: ${errorMsg.substring(0, 100)}...');
        } else {
          print('‚ùå Error en $url: $errorMsg');
        }
        continue;
      }
    }
  
    print('‚ùå No se pudo encontrar el servidor en ninguna URL');
    print('üí° Verifica que el servidor est√© ejecut√°ndose con: node server.js');
    return null;
  }

  /// Prueba la conexi√≥n con diagn√≥stico completo
  static Future<Map<String, dynamic>> testConnectionWithDiagnostic() async {
    final diagnostic = <String, dynamic>{
      'timestamp': DateTime.now().toIso8601String(),
      'tests': <String, dynamic>{},
      'workingUrl': null,
      'recommendations': <String>[],
      'urlsTested': <String>[],
      'serverInfo': null,
    };

    // Test 1: Buscar URL que funcione
    print('üß™ Iniciando diagn√≥stico completo...');
  
    for (final url in possibleUrls) {
      diagnostic['urlsTested'].add(url);
    }
  
    final workingUrl = await findWorkingUrl();
    diagnostic['workingUrl'] = workingUrl;

    if (workingUrl == null) {
      diagnostic['recommendations'].addAll([
        '1. Verifica que el servidor Node.js est√© ejecut√°ndose',
        '2. Ejecuta: node server.js en la carpeta del servidor',
        '3. Verifica que el puerto 3005 est√© libre',
        '4. Revisa la configuraci√≥n del firewall',
        '5. Aseg√∫rate de estar en la misma red WiFi',
        '6. Prueba cambiar la IP en possibleUrls[]',
      ]);
      return diagnostic;
    }

    // Test 2: Prueba detallada de la API
    try {
      print('üß™ Probando endpoint /test...');
      final response = await http.get(
        Uri.parse('$workingUrl/test'),
        headers: {'Content-Type': 'application/json'},
      ).timeout(timeout);

      diagnostic['tests']['api_test'] = {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
        'responseTime': DateTime.now().millisecondsSinceEpoch,
        'bodyLength': response.body.length,
      };

      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        diagnostic['serverInfo'] = data;
        print('‚úÖ Test de API exitoso');
        print('üìä Base de datos: ${data['database']}');
        print('‚è±Ô∏è Tiempo de respuesta: ${data['queryTime']}ms');
      }
    } catch (e) {
      print('‚ùå Error en test de API: $e');
      diagnostic['tests']['api_test'] = {
        'success': false,
        'error': e.toString(),
      };
    }

    // Test 3: Prueba consulta de facturas
    try {
      print('üß™ Probando consulta de facturas...');
      final response = await http.get(
        Uri.parse('$workingUrl/invoices/by-cardcode/TEST123'),
        headers: {'Content-Type': 'application/json'},
      ).timeout(timeout);

      diagnostic['tests']['invoice_query'] = {
        'success': response.statusCode == 200 || response.statusCode == 404,
        'statusCode': response.statusCode,
        'canQueryInvoices': response.statusCode != 500,
      };
    
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        print('‚úÖ Test de consulta exitoso');
        print('üìÑ Respuesta: ${data['message']}');
      }
    } catch (e) {
      print('‚ùå Error en test de consulta: $e');
      diagnostic['tests']['invoice_query'] = {
        'success': false,
        'error': e.toString(),
      };
    }

    // Test 4: Prueba diagn√≥stico del servidor
    try {
      print('üß™ Probando endpoint /diagnostic...');
      final response = await http.get(
        Uri.parse('$workingUrl/diagnostic'),
        headers: {'Content-Type': 'application/json'},
      ).timeout(timeout);

      diagnostic['tests']['server_diagnostic'] = {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
      };
    
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        diagnostic['serverDiagnostic'] = data;
        print('‚úÖ Diagn√≥stico del servidor obtenido');
        print('üíæ Base de datos: ${data['database']?['status']}');
        print('üñ•Ô∏è Sistema: ${data['server']?['platform']}');
      }
    } catch (e) {
      print('‚ùå Error en diagn√≥stico del servidor: $e');
      diagnostic['tests']['server_diagnostic'] = {
        'success': false,
        'error': e.toString(),
      };
    }

    print('üéØ Diagn√≥stico completado');
    return diagnostic;
  }

  /// Prueba la conexi√≥n b√°sica
  static Future<bool> testConnection() async {
    try {
      final workingUrl = await findWorkingUrl();
      return workingUrl != null;
    } catch (e) {
      print('‚ùå Error en test de conexi√≥n: $e');
      return false;
    }
  }

  /// Obtiene las facturas de un CardCode espec√≠fico con reintentos
  static Future<List<InvoiceModel>> getInvoicesByCardCode(String cardCode) async {
    if (cardCode.isEmpty) {
      throw Exception('CardCode no puede estar vac√≠o');
    }

    print('üîç Iniciando consulta de facturas...');
    print('üìã CardCode solicitado: $cardCode');

    // Buscar URL que funcione
    final workingUrl = await findWorkingUrl();
    if (workingUrl == null) {
      throw Exception('No se pudo conectar con el servidor ORAL-PLUS. Verifica que est√© ejecut√°ndose.');
    }

    try {
      print('üîç Consultando facturas para CardCode: $cardCode');
      print('üåê URL: $workingUrl/invoices/by-cardcode/$cardCode');
    
      final startTime = DateTime.now();
      final response = await http.get(
        Uri.parse('$workingUrl/invoices/by-cardcode/$cardCode'),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
      ).timeout(timeout);
    
      final responseTime = DateTime.now().difference(startTime).inMilliseconds;
      print('üì° Respuesta HTTP: ${response.statusCode} (${responseTime}ms)');

      if (response.statusCode == 200) {
        final data = json.decode(response.body);
      
        if (data['success'] == true) {
          print('‚úÖ Respuesta exitosa de la API');
          print('üìÑ Facturas encontradas: ${data['count']}');
          print('‚è±Ô∏è Tiempo de consulta en servidor: ${data['queryTime']}ms');
        
          if (data['count'] == 0) {
            print('üéâ Usuario a paz y salvo: ${data['message']}');
            return [];
          }

          final List<dynamic> invoicesJson = data['invoices'] ?? [];
          final List<InvoiceModel> invoices = [];
          int processedCount = 0;
          int validCount = 0;

          // Asegurarse de que el formato de fecha est√° inicializado
          await initializeDateFormatting();

          for (var invoiceJson in invoicesJson) {
            try {
              processedCount++;
              final invoice = InvoiceModel.fromJson(invoiceJson);
            
              if (invoice.cardCode.trim().toUpperCase() == cardCode.trim().toUpperCase()) {
                invoices.add(invoice);
                validCount++;
                print('‚úÖ Factura $validCount: ${invoice.docNum} - ${invoice.formattedAmount}');
              } else {
                print('‚ö†Ô∏è Factura ${invoice.docNum} no coincide con CardCode (tiene: ${invoice.cardCode})');
              }
            } catch (e) {
              print('‚ùå Error procesando factura $processedCount: $e');
            }
          }

          print('üéØ Resumen de procesamiento:');
          print('   üì• Recibidas: ${invoicesJson.length}');
          print('   üîÑ Procesadas: $processedCount');
          print('   ‚úÖ V√°lidas: $validCount');
          print('   üìä Estad√≠sticas: ${data['statistics']}');
        
          return invoices;
        } else {
          throw Exception(data['message'] ?? 'Error en la respuesta de la API');
        }
      } else if (response.statusCode == 404) {
        print('üì≠ No se encontraron facturas para CardCode: $cardCode');
        return [];
      } else {
        print('‚ùå Error HTTP ${response.statusCode}');
        print('üìÑ Respuesta: ${response.body}');
        throw Exception('Error ${response.statusCode}: ${response.body}');
      }
    } catch (e) {
      print('‚ùå Error obteniendo facturas por CardCode: $e');
    
      if (e is SocketException) {
        throw Exception('Error de conexi√≥n: El servidor no est√° disponible. Verifica que est√© ejecut√°ndose.');
      } else if (e is HttpException) {
        throw Exception('Error HTTP: $e');
      } else if (e.toString().contains('TimeoutException')) {
        throw Exception('Timeout: La consulta tard√≥ demasiado tiempo (>${timeout.inSeconds}s)');
      } else {
        rethrow;
      }
    }
  }

  /// M√©todo para limpiar la URL en cache (√∫til para reconectar)
  static void resetConnection() {
    final previousUrl = _workingUrl;
    _workingUrl = null;
    print('üîÑ Cache de conexi√≥n limpiado');
    if (previousUrl != null) {
      print('üóëÔ∏è URL anterior: $previousUrl');
    }
    print('üîç Pr√≥xima consulta buscar√° servidor autom√°ticamente');
  }

  /// Obtiene informaci√≥n del servidor
  static Future<Map<String, dynamic>?> getServerInfo() async {
    try {
      print('üìä Obteniendo informaci√≥n del servidor...');
      final workingUrl = await findWorkingUrl();
      if (workingUrl == null) {
        print('‚ùå No se pudo conectar para obtener info del servidor');
        return null;
      }

      final response = await http.get(
        Uri.parse('$workingUrl/test'),
        headers: {'Content-Type': 'application/json'},
      ).timeout(timeout);

      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        print('‚úÖ Informaci√≥n del servidor obtenida');
        print('üñ•Ô∏è Host: ${data['server']?['host']}');
        print('üîß Node.js: ${data['server']?['nodeVersion']}');
        print('üíæ Base de datos: ${data['database_info']?['database']}');
        return data;
      }
      return null;
    } catch (e) {
      print('‚ùå Error obteniendo info del servidor: $e');
      return null;
    }
  }

  /// Valida si un CardCode existe
  static Future<bool> validateCardCode(String cardCode) async {
    try {
      await getInvoicesByCardCode(cardCode);
      return true;
    } catch (e) {
      return false;
    }
  }

  /// Obtiene estad√≠sticas de un CardCode
  static Future<Map<String, dynamic>?> getCardCodeStatistics(String cardCode) async {
    try {
      print('üìä Obteniendo estad√≠sticas para CardCode: $cardCode');
      final workingUrl = await findWorkingUrl();
      if (workingUrl == null) return null;

      final response = await http.get(
        Uri.parse('$workingUrl/invoices/by-cardcode/$cardCode'),
        headers: {'Content-Type': 'application/json'},
      ).timeout(timeout);

      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        if (data['success'] == true) {
          final stats = {
            'count': data['count'] ?? 0,
            'totalAmount': data['totalAmount'] ?? 0.0,
            'overdueCount': data['overdueCount'] ?? 0,
            'urgentCount': data['urgentCount'] ?? 0,
            'upcomingCount': data['upcomingCount'] ?? 0,
            'normalCount': data['normalCount'] ?? 0,
            'cardCode': data['cardCode'],
            'timestamp': data['timestamp'],
            'queryTime': data['queryTime'],
          };
        
          print('‚úÖ Estad√≠sticas obtenidas:');
          print('   üìÑ Total facturas: ${stats['count']}');
          print('   üí∞ Monto total: \$${stats['totalAmount']}');
          print('   ‚ö†Ô∏è Vencidas: ${stats['overdueCount']}');
          print('   üî• Urgentes: ${stats['urgentCount']}');
        
          return stats;
        }
      }
      return null;
    } catch (e) {
      print('‚ùå Error obteniendo estad√≠sticas: $e');
      return null;
    }
  }
}